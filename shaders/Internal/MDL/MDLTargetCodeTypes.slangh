/***************************************************************************
 # Copyright (c) 2015-23, NVIDIA CORPORATION. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 **************************************************************************/

// This file is adapted from the DXR example in the MDL SDK:
// https://github.com/NVIDIA/MDL-SDK/blob/master/examples/mdl_sdk/dxr/content/mdl_target_code_types.hlsl

// clang-format off
#pragma once

// compiler constants defined from outside:
// - MDL_NUM_TEXTURE_RESULTS
// - MDL_USE_DERIVS
// - MDL_DF_HANDLE_SLOT_MODE (0, 1, 2, 4, or 8)

struct Derived_float {
    float val;
    float dx;
    float dy;
};

struct Derived_float2 {
    float2 val;
    float2 dx;
    float2 dy;
};

struct Derived_float3 {
    float3 val;
    float3 dx;
    float3 dy;
};

struct Derived_float4 {
    float4 val;
    float4 dx;
    float4 dy;
};


struct Shading_state_material
{
    /// The result of state::normal().
    /// It represents the shading normal as determined by the renderer.
    /// This field will be updated to the result of \c "geometry.normal" by BSDF init functions,
    /// if requested during code generation.
    float3            normal;

    /// The result of state::geometry_normal().
    /// It represents the geometry normal as determined by the renderer.
    float3            geom_normal;

    /// The result of state::position().
    /// It represents the position where the material should be evaluated.
#if defined(MDL_USE_DERIVS)
    Derived_float3    position;
#else
    float3            position;
#endif

    /// The result of state::animation_time().
    /// It represents the time of the current sample in seconds.
    float             animation_time;

    /// An array containing the results of state::texture_coordinate(i).
    /// The i-th entry represents the texture coordinates of the i-th texture space at the
    /// current position.
#if defined(MDL_USE_DERIVS)
    Derived_float3    text_coords[1];
#else
    float3            text_coords[1];
#endif

    /// An array containing the results of state::texture_tangent_u(i).
    /// The i-th entry represents the texture tangent vector of the i-th texture space at the
    /// current position, which points in the direction of the projection of the tangent to the
    /// positive u axis of this texture space onto the plane defined by the original
    /// surface normal.
    float3            tangent_u[1];

    /// An array containing the results of state::texture_tangent_v(i).
    /// The i-th entry represents the texture bitangent vector of the i-th texture space at the
    /// current position, which points in the general direction of the positive v axis of this
    /// texture space, but is orthogonal to both the original surface normal and the tangent
    /// of this texture space.
    float3            tangent_v[1];

    /// The texture results lookup table.
    /// Values will be modified by BSDF init functions to avoid duplicate texture fetches
    /// and duplicate calculation of values.
    /// This field is only relevant for code generated with
    /// #mi::neuraylib::IMdl_backend::translate_material_df() or
    /// #mi::neuraylib::ILink_unit::add_material_df(). In other cases this may be NULL.
#if defined(MDL_NUM_TEXTURE_RESULTS) && (MDL_NUM_TEXTURE_RESULTS > 0)
    float4            text_results[MDL_NUM_TEXTURE_RESULTS];
#endif
    /// An offset for accesses to the read-only data segment. Will be added before
    /// calling any "mdl_read_rodata_as_*" function.
    /// The data of the read-only data segment is accessible as the first segment
    /// (index 0) returned by #mi::neuraylib::ITarget_code::get_ro_data_segment_data().
    uint ro_data_segment_offset;

    /// A 4x4 transformation matrix transforming from world to object coordinates.
    /// It is used by the state::transform_*() methods.
    /// This field is only used if the uniform state is included.
    float4x4          world_to_object;

    /// A 4x4 transformation matrix transforming from object to world coordinates.
    /// It is used by the state::transform_*() methods.
    /// This field is only used if the uniform state is included.
    float4x4          object_to_world;

    /// The result of state::object_id().
    /// It is an application-specific identifier of the hit object as provided in a scene.
    /// It can be used to make instanced objects look different in spite of the same used material.
    /// This field is only used if the uniform state is included.
    uint              object_id;

    /// The result of state::meters_per_scene_unit().
    /// The field is only used if the \c "fold_meters_per_scene_unit" option is set to false.
    /// Otherwise, the value of the \c "meters_per_scene_unit" option will be used in the code.
    float             meters_per_scene_unit;

    /// An offset to add to any argument block read accesses.
    uint              arg_block_offset;

#if defined(RENDERER_STATE_TYPE)
    /// A user-defined structure that allows to pass renderer information; for instance about the
    /// hit-point or buffer references; to mdl run-time functions. This is especially required for
    /// the scene data access. The fields of this structure are not altered by generated code.
    RENDERER_STATE_TYPE renderer_state;
#endif
};

/// The texture wrap modes as defined by \c tex::wrap_mode in the MDL specification.
typedef int Tex_wrap_mode;
#define TEX_WRAP_CLAMP            0
#define TEX_WRAP_REPEAT           1
#define TEX_WRAP_MIRRORED_REPEAT  2
#define TEX_WRAP_CLIP             3

/// The type of events created by BSDF importance sampling.
typedef int Bsdf_event_type;
#define BSDF_EVENT_ABSORB       0
#define BSDF_EVENT_DIFFUSE      (1 << 0)
#define BSDF_EVENT_GLOSSY       (1 << 1)
#define BSDF_EVENT_SPECULAR     (1 << 2)
#define BSDF_EVENT_REFLECTION   (1 << 3)
#define BSDF_EVENT_TRANSMISSION (1 << 4)
#define BSDF_EVENT_DIFFUSE_REFLECTION    (BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION)
#define BSDF_EVENT_DIFFUSE_TRANSMISSION  (BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION)
#define BSDF_EVENT_GLOSSY_REFLECTION     (BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION)
#define BSDF_EVENT_GLOSSY_TRANSMISSION   (BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION)
#define BSDF_EVENT_SPECULAR_REFLECTION   (BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION)
#define BSDF_EVENT_SPECULAR_TRANSMISSION (BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION)

/// The type of events created by EDF importance sampling.
typedef int Edf_event_type;
#define EDF_EVENT_NONE          0
#define EDF_EVENT_EMISSION      (1 << 0)

/// MBSDFs can consist of two parts, which can be selected using this enumeration.
typedef int Mbsd_part;
#define MBSDF_DATA_REFLECTION    0
#define MBSDF_DATA_TRANSMISSION  1


/// The calling code can mark the \c x component of an IOR field in *_data with
/// \c BSDF_USE_MATERIAL_IOR, to make the BSDF functions use the MDL material's IOR
/// for this IOR field.
#define BSDF_USE_MATERIAL_IOR (-1.0f)

/// Input and output structure for BSDF sampling data.
struct Bsdf_sample_data {
    float3 ior1;                    ///< mutual input: IOR current medium
    float3 ior2;                    ///< mutual input: IOR other side
    float3 k1;                      ///< mutual input: outgoing direction

    float3 k2;                      ///< output: incoming direction
    float4 xi;                      ///< input: pseudo-random sample numbers
    float pdf;                      ///< output: pdf (non-projected hemisphere)
    float3 bsdf_over_pdf;           ///< output: bsdf * dot(normal, k2) / pdf
    Bsdf_event_type event_type;     ///< output: the type of event for the generated sample
    int handle;                     ///< output: handle of the sampled elemental BSDF (lobe)
};

/// Input and output structure for BSDF evaluation data.
struct Bsdf_evaluate_data {
    float3 ior1;                    ///< mutual input: IOR current medium
    float3 ior2;                    ///< mutual input: IOR other side
    float3 k1;                      ///< mutual input: outgoing direction

    float3 k2;                      ///< input: incoming direction
    #if (MDL_DF_HANDLE_SLOT_MODE != 0)
        int handle_offset;          ///< output: handle offset to allow the evaluation of more then
                                    ///  DF_HANDLE_SLOTS handles, calling 'evaluate' multiple times
    #endif
    #if (MDL_DF_HANDLE_SLOT_MODE == 0)
        float3 bsdf_diffuse;        ///< output: (diffuse part of the) bsdf * dot(normal, k2)
        float3 bsdf_glossy;         ///< output: (glossy part of the) bsdf * dot(normal, k2)
    #else
        float3 bsdf_diffuse[MDL_DF_HANDLE_SLOT_MODE]; ///< output: (diffuse) bsdf * dot(normal, k2)
        float3 bsdf_glossy[MDL_DF_HANDLE_SLOT_MODE];  ///< output: (glossy) bsdf * dot(normal, k2)
    #endif
    float pdf;                      ///< output: pdf (non-projected hemisphere)
};

/// Input and output structure for BSDF PDF calculation data.
struct Bsdf_pdf_data {
    float3 ior1;                    ///< mutual input: IOR current medium
    float3 ior2;                    ///< mutual input: IOR other side
    float3 k1;                      ///< mutual input: outgoing direction

    float3 k2;                      ///< input: incoming direction
    float pdf;                      ///< output: pdf (non-projected hemisphere)
};

/// Input and output structure for BSDF auxiliary calculation data.
struct Bsdf_auxiliary_data {
    float3 ior1;                    ///< mutual input: IOR current medium
    float3 ior2;                    ///< mutual input: IOR other side
    float3 k1;                      ///< mutual input: outgoing direction

    #if (MDL_DF_HANDLE_SLOT_MODE != 0)
        int handle_offset;          ///< output: handle offset to allow the evaluation of more then
                                    ///  DF_HANDLE_SLOTS handles, calling 'auxiliary' multiple times
    #endif
    #if (MDL_DF_HANDLE_SLOT_MODE == 0)
        float3 albedo_diffuse;      ///< output: albedo
        float3 albedo_glossy;       ///< output: albedo
        float3 normal;              ///< output: normal
        float3 roughness;
    #else
        float3 albedo_diffuse[MDL_DF_HANDLE_SLOT_MODE]; ///< output: albedo
        float3 albedo_glossy[MDL_DF_HANDLE_SLOT_MODE]; ///< output: albedo
        float3 normal[MDL_DF_HANDLE_SLOT_MODE]; ///< output: normal
        float3 roughness[MDL_DF_HANDLE_SLOT_MODE];
    #endif
};

/// Input and output structure for EDF sampling data.
struct Edf_sample_data
{
    float4 xi;                      ///< input: pseudo-random sample numbers
    float3 k1;                      ///< output: outgoing direction
    float pdf;                      ///< output: pdf (non-projected hemisphere)
    float3 edf_over_pdf;            ///< output: edf * dot(normal,k1) / pdf
    Edf_event_type event_type;      ///< output: the type of event for the generated sample
    int handle;                     ///< output: handle of the sampled elemental EDF (lobe)
};

/// Input and output structure for EDF evaluation data.
struct Edf_evaluate_data
{
    float3 k1;                      ///< input: outgoing direction
    #if (MDL_DF_HANDLE_SLOT_MODE != 0)
        int handle_offset;          ///< output: handle offset to allow the evaluation of more then
                                    ///  DF_HANDLE_SLOTS handles, calling 'evaluate' multiple times
    #endif
    float cos;                      ///< output: dot(normal, k1)
    #if (MDL_DF_HANDLE_SLOT_MODE == 0)
        float3 edf;                 ///< output: edf
    #else
        float3 edf[MDL_DF_HANDLE_SLOT_MODE]; ///< output: edf
    #endif
    float pdf;                      ///< output: pdf (non-projected hemisphere)
};

/// Input and output structure for EDF PDF calculation data.
struct Edf_pdf_data
{
    float3 k1;                      ///< input: outgoing direction
    float pdf;                      ///< output: pdf (non-projected hemisphere)
};

/// Input and output structure for EDF PDF calculation data.
struct Edf_auxiliary_data
{
    float3 k1;                      ///< input: outgoing direction
    #if (MDL_DF_HANDLE_SLOT_MODE != 0)
        int handle_offset;          ///< output: handle offset to allow the evaluation of more then
                                    ///  DF_HANDLE_SLOTS handles, calling 'auxiliary' multiple times
    #endif

    // reserved for future use
};

// clang-format on
