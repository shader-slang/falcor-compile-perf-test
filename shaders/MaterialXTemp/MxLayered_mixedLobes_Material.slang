// File generated by SlangShaderGenerator from a MaterialX source.

#pragma once
#include "Utils/HostDeviceShared.slangh"
import Internal.MaterialNetwork.MaterialX.MxCommon.MxAssetData;
BEGIN_NAMESPACE_FALCOR
struct mixedLobesBuffer
{
    // uniform inputs
    TextureHandle grid_image_file;
    float2 noise_scale_in2 = float2(10, 10);
    float switch_treshold_low = 0.4;
    float switch_treshold_high = 0.6;

    MxAssetData assetData;
};
struct mixedLobesPayload
{
    // ID of the buffer in which mixedLobesBuffer is found
    uint mBufferID;
};
END_NAMESPACE_FALCOR
#ifndef HOST_CODE
__exported import Rendering.Materials.IMaterial;
__exported import Rendering.Materials.IMaterialInstance;
import Internal.MaterialNetwork.MaterialX.libraries.stdlib.genslang.lib.mxProcedural;
import Internal.MaterialNetwork.MaterialX.MxCommon.MxWeights;
import Internal.MaterialNetwork.MaterialX.MxCommon.MxLayeredMaterialInstance;

import Scene.ShadingData;
import Scene.Material.MaterialSystem;
import Scene.Material.TextureSampler;
import Rendering.Materials.IBSDF;
import Utils.SlangUtils;

import Utils.Math.MathHelpers;
struct BSDF
{
    int index;
    [mutating] void setBsdf(int i) { index = i + 1; }
    [mutating] void setLayer(int i) { index = - i - 1; }
    bool isBsdf() { return index > 0; }
    bool isLayer() { return index < 0; }
    int getIndex() { return abs(index) - 1; }
}
typealias EDF=BSDF;
struct surfaceshader { int rootindex; }
typealias displacementshader=float3;

static const EDF kEmptyEDF = {0};
#define M_FLOAT_EPS 1e-8

// The struct will eventually be specialized for each material, at which point we want an alias

struct LayeredData_mixedLobes : IMxLayeredMaterialData
{
    float3 bsdfWeights[2];                      ///< Weights of each BSDFs pre layering
    float3 layerWeights[ArrayMax<1, 1>.value]; ///< Weight of each layer
    static const int bsdfCount = 2;             ///< Number of BSFDs
    static const int layerCount = 1;           ///< Number of layers
    float3 bsdfN[2];                            ///< Per-lobe normals, defaults to sd.frame.N (always valid and normalized)
    float3 bsdfT[2];                            ///< Per-lobe tangents, defaults to sd.frame.T (always valid and normalized)
    float transmits[2];                         ///< if flag is true, the BTDF will contribute to transmission (if possible)
    bool frontFacing;                                    ///< which side of the layer stack are we evaluating?

    int getBsdfCount() { return bsdfCount; }
    int getLayerCount() { return layerCount; }

    float3 getBsdfWeight(int bsdfIndex) { return bsdfWeights[bsdfIndex]; }
    float3 getLayerWeight(int layerIndex) { return layerWeights[layerIndex]; }
    float3 getBsdfN(int bsdfIndex) { return bsdfN[bsdfIndex]; }
    float3 getBsdfT(int bsdfIndex) { return bsdfT[bsdfIndex]; }
    float getTransmits(int bsdfIndex) { return transmits[bsdfIndex]; }
    bool getIsFrontFacing() { return frontFacing; }
    bool hasSubsurfaceData() { return false; };
    MxSubsurfaceData getSubsurfaceData() { return {}; };
    OrenNayarBRDF bsdf0;
    OrenNayarBRDF bsdf1;
    [mutating] void setBsdf<TBSDF : IBSDF>(int bsdfIndex, TBSDF bsdf)
    {
        switch(bsdfIndex)
        {
            case 0: bsdf0 = reinterpret<OrenNayarBRDF, TBSDF>(bsdf); break;
            default: bsdf1 = reinterpret<OrenNayarBRDF, TBSDF>(bsdf); break;
        }
    }
    IBSDF getBsdf(int bsdfIndex)
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0;
            default: return bsdf1;
        }
    }
    float3 eval<S : ISampleGenerator>(int bsdfIndex, const float3 wi, const float3 wo, inout S sg)
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0.eval(wi, wo, sg);
            default: return bsdf1.eval(wi, wo, sg);
        }
    }
    bool sample<S : ISampleGenerator>( int bsdfIndex, const float3 wi, out float3 wo, out float pdf, out float3 weight, out uint lobeType, inout S sg )
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0.sample(wi, wo, pdf, weight, lobeType, sg);
            default: return bsdf1.sample(wi, wo, pdf, weight, lobeType, sg);
        }
    }
    float evalPdf(int bsdfIndex, const float3 wi, const float3 wo)
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0.evalPdf(wi, wo);
            default: return bsdf1.evalPdf(wi, wo);
        }
    }
    AlbedoContributions evalAlbedo(int bsdfIndex, const float3 wi, const LobeType lobetype)
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0.evalAlbedo(wi, lobetype);
            default: return bsdf1.evalAlbedo(wi, lobetype);
        }
    }
    RoughnessInformation getRoughnessInformation(int bsdfIndex, const float3 wi)
    {
        switch(bsdfIndex)
        {
            case 0: return bsdf0.getRoughnessInformation(wi);
            default: return bsdf1.getRoughnessInformation(wi);
        }
    }
}
#define TMxLayeredMaterialData LayeredData_mixedLobes

struct mixedLobesStruct
{
    // BEGIN varying inputs
    // END varying inputs
    // BEGIN uniform inputs
    TextureHandle grid_image_file;
    float2 noise_scale_in2 = float2(10, 10);
    float switch_treshold_low = 0.4;
    float switch_treshold_high = 0.6;
    // BEGIN uniform inputs
    ShadingData sd;
    MaterialSystem ms;
    ITextureSampler lod;
    SamplerState samplerState;
    float4x4 objectFromWorld;
    float4x4 worldFromObject;
    float3x3 objectFromWorldIT;
    float3x3 worldFromObjectIT;

    // Cludge for normal mapping, the last lobe that has mapped normal/tangent (not equal to the standard) wins

    int mxStack_nextBsdf = 0;
    int mxStack_nextLayer = 0;
    TMxLayeredMaterialData mxStack;
    // BEGIN outputs
    BSDF out1 = {0};
    // END outputs
    __init(mixedLobesBuffer _uniformData, ShadingData _sd, MaterialSystem _ms, ITextureSampler _lod, MaterialHeader header)
    {
        sd = _sd;
        ms = _ms;
        lod = _lod;
        samplerState = ms.getTextureSampler(header.getDefaultTextureSamplerID());

        mxStack_nextBsdf = 0;
        mxStack_nextLayer = 0;

        static const float4x4 identity4x4 = {1,0,0,0,  0,1,0,0, 0,0,1,0,  0,0,0,1};

        float4x4 worldFromInstance = identity4x4;
        float4x4 instanceFromWorld = identity4x4;
        objectFromWorld = mul(_uniformData.assetData.objectFromInstance, instanceFromWorld);
        worldFromObject = mul(worldFromInstance, _uniformData.assetData.instanceFromObject);
        objectFromWorldIT = (float3x3)transpose(worldFromObject);
        worldFromObjectIT = (float3x3)transpose(objectFromWorld);

        // BEGIN copy uniform inputs into member variables
        grid_image_file = _uniformData.grid_image_file;
        noise_scale_in2 = _uniformData.noise_scale_in2;
        switch_treshold_low = _uniformData.switch_treshold_low;
        switch_treshold_high = _uniformData.switch_treshold_high;
        // END copy uniform inputs into member variables
    }

    [mutating] void evalShaderGraph()
    {
        float3 geomprop_Nworld_out = (geomprop_Nworld_space == mx_space_world ? sd.frame.N : mul(objectFromWorldIT, sd.frame.N));
        float2 ST_out = sd.uv;
        float3 grid_image_out = ms.sampleTexture(grid_image_file, samplerState, ST_out, float4(grid_image_default, 0), lod).xyz;
        float2 noise_scale_out = ST_out * noise_scale_in2;
        float perlin_out = (mx_noise_float(noise_scale_out) * perlin_amplitude + perlin_pivot);
        float switch_treshold_out = smoothstep(switch_treshold_low, switch_treshold_high, perlin_out);
        BSDF red_out = {0};
        mx_oren_nayar_diffuse_bsdf(red_weight, red_color, red_roughness, geomprop_Nworld_out, red_out);
        BSDF grid_out = {0};
        mx_oren_nayar_diffuse_bsdf(grid_weight, grid_image_out, grid_roughness, geomprop_Nworld_out, grid_out);
        BSDF mixedLobes_out = {0};
        mx_mix_bsdf(red_out, grid_out, switch_treshold_out, mixedLobes_out);
        out1 = mixedLobes_out;
    }

//private:
    [mutating] void mx_oren_nayar_diffuse_bsdf(float weight, float3 color, float roughness, float3 N, out BSDF bsdf)
    {
        bsdf.setBsdf(mxStack_nextBsdf++);
        mxStack.bsdfWeights[bsdf.getIndex()] = float3(weight);
    
        mxStack.setBsdf(bsdf.getIndex(), createMxOrenNayar(color, roughness, N));
    
        mxStack.bsdfN[bsdf.getIndex()] = normalize(N);
        mxStack.bsdfT[bsdf.getIndex()] = sd.frame.T;
        orthogonalizeVectors(mxStack.bsdfN[bsdf.getIndex()], mxStack.bsdfT[bsdf.getIndex()]);
    }

    [mutating] void mx_mix_bsdf(BSDF in1, BSDF in2, float mix, out BSDF result)
    {
        // The inputs have been handled by the SlangShaderGenerator node walking preprocess
        result.setLayer(mxStack_nextLayer++);
        mxStack.layerWeights[result.getIndex()] = float3(1.f);
    
        if (in1.isBsdf())
            mxStack.bsdfWeights[in1.getIndex()] *= mix;
        else
            mxStack.layerWeights[in1.getIndex()] *= mix;
    
        if (in2.isBsdf())
            mxStack.bsdfWeights[in2.getIndex()] *= (1 - mix);
        else
            mxStack.layerWeights[in2.getIndex()] *= (1 - mix);
    }

//private: // constant non-editable inputs
    static const int geomprop_Nworld_space = 2;
    static const int ST_index = 0;
    static const float red_weight = 1;
    static const float3 red_color = float3(1, 0, 0);
    static const float red_roughness = 0;
    static const int grid_image_layer = 0;
    static const float3 grid_image_default = float3(0, 0, 0);
    static const int grid_image_uaddressmode = 2;
    static const int grid_image_vaddressmode = 2;
    static const int grid_image_filtertype = 1;
    static const int grid_image_framerange = 0;
    static const int grid_image_frameoffset = 0;
    static const int grid_image_frameendaction = 0;
    static const float2 grid_image_uv_scale = float2(1, 1);
    static const float2 grid_image_uv_offset = float2(0, 0);
    static const float grid_weight = 1;
    static const float grid_roughness = 0;
    static const float perlin_amplitude = 0.5;
    static const float perlin_pivot = 0.5;
}

// This generated weights calculator will always be used, can be public
struct Layered_mixedLobes_WeightsCalculator : IMxLayeredWeightCalculator
{
    void calculateWeights<let TBsdfCount : int, let TLayerCount : int, TLayeredMaterialData : IMxLayeredMaterialData>(const TLayeredMaterialData data, float3 wiLocal[TBsdfCount], bool isFrontFacing, out MxWeights<TBsdfCount> weights)
    {
        if (isFrontFacing)
        {
            const float3 Wlb0 = data.getBsdfWeight(0);
            const float3 Wlb1 = data.getBsdfWeight(1);
            const float3 Wly0 = data.getLayerWeight(0);


            const float3 n0 = Wlb0;
            const float3 n1 = Wlb1;
            const float3 n2 = Wly0;
            const float3 n3 = (n0 + n1);
            const float3 n4 = (n0 / n3);
            const float3 n5 = (n1 / n3);
            const float3 n6 = (n2 * n4);
            const float3 n7 = (n2 * n5);
            weights.bsdfWeights[0] = n6;
            weights.bsdfWeights[1] = n7;

        }
        else
        {
            const float3 Wlb0 = data.getBsdfWeight(0);
            const float3 Wlb1 = data.getBsdfWeight(1);
            const float3 Wly0 = data.getLayerWeight(0);


            const float3 n0 = Wlb0;
            const float3 n1 = Wlb1;
            const float3 n2 = Wly0;
            const float3 n3 = (n0 + n1);
            const float3 n4 = (n0 / n3);
            const float3 n5 = (n1 / n3);
            const float3 n6 = (n2 * n4);
            const float3 n7 = (n2 * n5);
            weights.bsdfWeights[0] = n6;
            weights.bsdfWeights[1] = n7;

        }
    }
    void calculatePlainWeights<let TBsdfCount : int, let TLayerCount : int, TLayeredMaterialData : IMxLayeredMaterialData>(const TLayeredMaterialData data, out MxWeights<TBsdfCount> weights)
    {
        const float3 Wlb0 = data.getBsdfWeight(0);
        const float3 Wlb1 = data.getBsdfWeight(1);
        const float3 Wly0 = data.getLayerWeight(0);


        const float3 n0 = Wlb0;
        const float3 n1 = Wlb1;
        const float3 n2 = Wly0;
        const float3 n3 = (n0 + n1);
        const float3 n4 = (n0 / n3);
        const float3 n5 = (n1 / n3);
        const float3 n6 = (n2 * n4);
        const float3 n7 = (n2 * n5);
        weights.bsdfWeights[0] = n6;
        weights.bsdfWeights[1] = n7;

    }
}

struct Layered_mixedLobes_Material : MaterialBase, IMaterial
{
    mixedLobesPayload payload;

    typealias UsedMtlXGraph = mixedLobesStruct;
    typealias UsedMaterialInstance = MxLayeredMaterialInstance<2, 1, TMxLayeredMaterialData, Layered_mixedLobes_WeightsCalculator>;
    typedef UsedMaterialInstance MaterialInstance;

    UsedMaterialInstance setupMaterialInstance(const MaterialSystem ms, const ShadingData sd, const ITextureSampler lod, const uint hints)
    {
        mixedLobesBuffer data = ms.getBuffer(payload.mBufferID).Load<mixedLobesBuffer>(0);
        UsedMtlXGraph mtlXGraph  = UsedMtlXGraph( data, sd, ms, lod, header );

        mtlXGraph.evalShaderGraph();

        UsedMaterialInstance result;
        result.data = mtlXGraph.mxStack;
        
        result.data.frontFacing = sd.frontFacing;
        for (int i = 0; i < 2; ++i)
        {
            result.data.bsdfN[i] = mxBendNormal(sd.faceN, result.data.bsdfN[i], sd.V);
            orthogonalizeVectors(result.data.bsdfN[i], result.data.bsdfT[i]);
        }

        result.data.transmits[0] = 0.f;
        result.data.transmits[1] = 0.f;


        return result;
    }

    [Differentiable]
    UsedMaterialInstance setupDiffMaterialInstance(out DiffMaterialData diffData, const MaterialSystem ms, const ShadingData sd, const ITextureSampler lod, const uint hints)
    {
        diffData = DiffMaterialData();
        return no_diff setupMaterialInstance(ms, sd, lod, hints);
    }


}
#endif // HOST_CODE
    
